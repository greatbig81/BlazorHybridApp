@page "/"
@inject IJSRuntime JSRuntime
@using Microsoft.Maui.Media;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Reflection;
@using BlazorHybridApp.Services;
@using Microsoft.Maui.Graphics;
@using Microsoft.Maui.Graphics.Platform;

<h1>Camera Feed</h1>

<div class="video-container">
    <video id="cameraVideo" autoplay playsinline></video>

    @if (currentResult != null && currentResult.Objects.Count > 0)
    {
        <div class="overlay">
            @foreach (var obj in currentResult.Objects)
            {
                <div class="bbox" style="left: @(obj.RenderBoundingBox.X)px;
                            top: @(obj.RenderBoundingBox.Y)px;
                            width: @(obj.RenderBoundingBox.Width)px;
                            height: @(obj.RenderBoundingBox.Height)px;">
                    <span class="label">@obj.Name (@obj.Confidence.ToString("P0")), @obj.RenderBoundingBox.ToString()</span>
                </div>
            }
        </div>
    }
</div>
<br/>
<div class="controls">
    <button @onclick="ToggleCamera">카메라 시작(@isFrontCamera)</button>
    <button @onclick="StopCamera">카메라 중지(@isFrontCamera)</button>
    <button @onclick="CaptureFrame" disabled="@(!isCameraActive)">수동캡처</button>
    @if (!isAutoCapturing)
    {
        <button @onclick="StartAutoCapture" disabled="@(!isCameraActive)">자동캡쳐 시작</button>
    }
    else
    {
        <button @onclick="StopAutoCapture">자동캡쳐 중지</button>
    }
</div>

<div class="status">
    <p>카메라 상태: <strong>@(isCameraActive ? "활성" : "비활성")</strong></p>
    <p>자동 캡처: <strong>@(isAutoCapturing ? "ON" : "OFF")</strong></p>
    @if (videoInfo != null)
    {
        <p>해상도: @videoInfo.Width x @videoInfo.Height</p>
        <p>Paused: @videoInfo.Paused</p>
        <p>ReadyState: @videoInfo.ReadyState</p>
    }
</div>

@code {

    //private IJSObjectReference jsModule;
    private DotNetObjectReference<Home> dotnetReference;
    private bool isCameraActive = false;
    private bool isAutoCapturing = false;
    private VideoInfo videoInfo;
    private RecognitionResult currentResult;
    private bool isFrontCamera = true;
    private const int TARGET_WIDTH = 640;
    private const int TARGET_HEIGHT = 640;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // 첫 렌더링 시 JavaScript 함수가 준비되었음을 확인
            // 실제 카메라 시작은 버튼 클릭으로 분리하여 사용자 권한 요청을 명확히 합니다.

            // 초기 로드 시 앞면 카메라로 시작
            //await StartCamera("user");

            try
            {
                /*
                // JavaScript 모듈 로드
                jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./js/camera.js");

                // .NET 참조 생성 및 JavaScript에 전달
                dotnetReference = DotNetObjectReference.Create(this);
                await jsModule.InvokeVoidAsync("CameraHelper.setDotNetReference", dotnetReference);
                */
                                                                                                                                await StartCamera("user");

                // .NET 참조 생성 및 JavaScript에 전달
                dotnetReference = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("CameraHelper.setDotNetReference", dotnetReference);


            }
            catch (JSException ex)
            {
                Console.WriteLine($"[OnAfterRenderAsync] JS Error: {ex.Message}");
                // 사용자에게 오류 메시지를 표시할 수 있습니다.
            }

        }
    }

    private async Task ToggleCamera()
    {
        isFrontCamera = !isFrontCamera;

        // 새로운 facingMode 결정
        string facingMode = isFrontCamera ? "user" : "environment";

        // JavaScript 함수를 호출하여 카메라 전환
        await StartCamera(facingMode);
    }

    private async Task StartCamera(string facingMode)
    {
        // 1. MAUI Permissions API를 사용하여 카메라 접근 권한 요청
        var status = await Permissions.CheckStatusAsync<Permissions.Camera>();

        if (status != PermissionStatus.Granted)
        {
            status = await Permissions.RequestAsync<Permissions.Camera>();
        }

        if (status == PermissionStatus.Granted)
        {
            try
            {
                // 2. JavaScript 함수를 호출하여 브라우저 API를 통해 카메라를 켜고 스트림을 video 요소에 연결
                //await JSRuntime.InvokeVoidAsync("startCameraFeed", "cameraFeed", facingMode);

                bool success = await JSRuntime.InvokeAsync<bool>("CameraHelper.initialize", "cameraVideo", facingMode);

                if (success)
                {
                    isCameraActive = true;

                    // 비디오 정보 가져오기
                    await Task.Delay(500); // 비디오 로드 대기
                    await UpdateVideoInfo();

                    Console.WriteLine("카메라 시작됨");
                }
                else
                {
                    Console.WriteLine("카메라 시작 실패");
                }

            }
            catch (JSException ex)
            {
                Console.WriteLine($"JS Error: {ex.Message}");
                // 사용자에게 오류 메시지를 표시할 수 있습니다.
            }
        }
        else
        {
            // 권한 거부 시 사용자에게 알림
            // (예: MAUI DisplayAlert 사용)
            await Application.Current.MainPage.DisplayAlert("권한 필요", "카메라 사용을 허용해야 합니다.", "확인");
        }
    }

    // 카메라 중지
    private async Task StopCamera()
    {
        try
        {
            if (isAutoCapturing)
            {
                await StopAutoCapture();
            }

            await JSRuntime.InvokeVoidAsync("CameraHelper.stop");
            isCameraActive = false;
            videoInfo = null;
            Console.WriteLine("카메라 중지됨");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"카메라 중지 오류: {ex.Message}");
        }
    }

    public byte[] ReadImageResourceFile(string fileName)
    {
        try
        {
            // 1. 어셈블리 가져오기
            var assembly = Assembly.GetExecutingAssembly();
            string[] names = assembly.GetManifestResourceNames();

            // 디버깅 콘솔에 모든 리소스 이름을 출력하여 비교합니다.
            foreach (var name in names)
            {
                Console.WriteLine($"[DEBUG] Found Resource: {name}");
            }

            // 2. 리소스 이름 구성 (네임스페이스 + 폴더 경로 + 파일명)
            // 일반적으로 {프로젝트 기본 네임스페이스}.Resources.Images.{파일명} 입니다.
            // 프로젝트 이름이 'MauiBlazorApp'이라면:
            // "MauiBlazorApp.Resources.Images.my_image.png"
            var resourceName = $"BlazorHybridApp.Resources.Images.{fileName}";

            // 3. 스트림을 열어 데이터 읽기
            using (Stream? stream = assembly.GetManifestResourceStream(resourceName))
            {
                if (stream == null)
                {
                    Console.WriteLine($"경고: 리소스 '{resourceName}'를 찾을 수 없습니다.");
                    return null;
                }

                // 이미지 파일이 아닌 텍스트 파일인 경우:
                //using (var reader = new StreamReader(stream, Encoding.UTF8))
                //{
                //    return reader.ReadToEnd();
                //}

                // 이미지 파일인 경우: (byte[]로 읽기)
                using (var ms = new MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ReadImageResourceFile] 오류: {ex.Message}");
        }
        return null;
    }

    // 수동으로 프레임 캡처
    private async Task CaptureFrame()
    {
        try
        {
            // Base64 문자열로 이미지 받기
            string base64Data = await JSRuntime.InvokeAsync<string>(
            "CameraHelper.captureFrameAsBase64", 0.85);

            if (!string.IsNullOrEmpty(base64Data))
            {
                Console.WriteLine($"프레임 캡처됨: {base64Data.Length} chars");

                // Base64를 바이트 배열로 변환
                byte[] imageData = Convert.FromBase64String(base64Data);

                // 이미지 처리 (ObjectRecognitive 또는 직접 API 호출)
                await ProcessImage(imageData);
            }
            

            // [디버그용] 리소스에 포함된 파일을 직접 바이트 배열로 이미지 받아서 처리
            //byte[] imageData = ReadImageResourceFile("f.jpg");
            //await ProcessImage(imageData);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"프레임 캡처 오류: {ex.Message}");
        }
    }


    // 자동 캡처 토글
    private async Task ToggleAutoCapture()
    {
        if (isAutoCapturing)
        {
            await StopAutoCapture();
        }
        else
        {
            await StartAutoCapture();
        }
    }

    // 자동 캡처 시작
    private async Task StartAutoCapture()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("CameraHelper.startAutoCapture", 1000); // 1초 간격
            isAutoCapturing = true;
            Console.WriteLine("자동 캡처 시작");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"자동 캡처 시작 오류: {ex.Message}");
        }
    }

    // 자동 캡처 중지
    private async Task StopAutoCapture()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("CameraHelper.stopAutoCapture");
            isAutoCapturing = false;
            Console.WriteLine("자동 캡처 중지");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"자동 캡처 중지 오류: {ex.Message}");
        }
    }

    // JavaScript에서 호출되는 콜백 메서드
    [JSInvokable]
    public async Task OnFrameCaptured(string base64Data)
    {
        try
        {
            Console.WriteLine($"프레임 수신됨: {base64Data.Length} chars");

            // Base64를 바이트 배열로 변환
            byte[] imageData = Convert.FromBase64String(base64Data);

            // 이미지 처리
            await ProcessImage(imageData);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"프레임 처리 오류: {ex.Message}");
        }
    }

    // 이미지 처리 (API 호출 등)
    private async Task ProcessImage(byte[] imageData)
    {
        try
        {
            // 여기서 ObjectRecognitive API 호출 또는 직접 HTTP 요청
            // 예시: 직접 API 호출
            using var httpClient = new HttpClient();
            using var content = new ByteArrayContent(imageData);
            content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/octet-stream");
            content.Headers.ContentLength = imageData.Length;
            content.Headers.Add("saveroot", "/");

            // 2. Content Headers 출력
            Console.WriteLine("--- Content Headers ---");
            foreach (var header in content.Headers)
            {
                Console.WriteLine($"{header.Key}: {string.Join(", ", header.Value)}");
            }
            Console.WriteLine("-----------------------");

            // http://61.41.4.9:3031/api/image-cognitive
            HttpResponseMessage response = await httpClient.PostAsync("http://61.41.4.9:5051/api/image-cognitive", content);

            if (response.IsSuccessStatusCode)
            {
                string jsonResponse = await response.Content.ReadAsStringAsync();

                // JSON 파싱 및 결과 업데이트
                currentResult = ParseRecognitionResponse(jsonResponse);

                // UI 업데이트
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"이미지 처리 오류: {ex.Message}");
        }
    }

    // 비디오 정보 업데이트
    private async Task UpdateVideoInfo()
    {
        try
        {
            videoInfo = await JSRuntime.InvokeAsync<VideoInfo>("CameraHelper.getVideoInfo");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"비디오 정보 가져오기 오류: {ex.Message}");
        }
    }

    public class RecognizedObjectDto
    {
        [JsonPropertyName("obj_name")]
        public string Name { get; set; }

        [JsonPropertyName("confidence")]
        // JSON이 문자열로 float 값을 보내므로, float 대신 string으로 받습니다.
        public string ConfidenceString { get; set; }

        [JsonPropertyName("x")]
        public float X { get; set; }

        [JsonPropertyName("y")]
        public float Y { get; set; }

        [JsonPropertyName("w")]
        public float W { get; set; }

        [JsonPropertyName("h")]
        public float H { get; set; }
    }

    // JSON 파싱 (간단한 예시)
    private RecognitionResult ParseRecognitionResponse(string jsonString)
    {
        // 1. JSON을 DTO 리스트로 파싱
        var dtoList = JsonSerializer.Deserialize<List<RecognizedObjectDto>>(jsonString);

        if (dtoList == null)
        {
            return new RecognitionResult
            {
                Timestamp = DateTime.Now,
                Objects = new List<RecognizedObject>()
            };
        }

        // 2. DTO 리스트를 RecognizedObject 리스트로 변환
        var recognizedObjects = dtoList.Select(dto => 
        {
            // Confidence 문자열을 float으로 변환 (소수점 구분을 위해 InvariantCulture 사용)
            float confidence = 0f;
            if (!float.TryParse(dto.ConfidenceString, NumberStyles.Any, CultureInfo.InvariantCulture, out confidence))
            {
                Console.WriteLine($"경고: 신뢰도 값 '{dto.ConfidenceString}' 파싱 실패.");
            }

            var scaledBox = new BoundingBox
            {
                X = (int)dto.X,
                Y = (int)dto.Y,
                Width = (int)dto.W,
                Height = (int)dto.H
            };

            return new RecognizedObject
            {
                Name = dto.Name,
                Confidence = confidence,                
                BoundingBox = scaledBox, // 또는 null
                OriginalBoundingBox = null
            };
        }).ToList();

        // 3. 최종 RecognitionResult 객체 생성
        var tRet = new RecognitionResult
            {
                Timestamp = DateTime.Now, // 현재 시간으로 설정
                Objects = recognizedObjects,
                OriginalImageSize = new SizeF(videoInfo.Width, videoInfo.Height),   // 임의의 값으로 설정
                ScaledImageSize = new SizeF(TARGET_WIDTH, TARGET_HEIGHT),            // 임의의 값으로 설정
                RenderedImageSize = new SizeF(videoInfo.renderedWidth, videoInfo.renderedHeight)
            };

        ConvertCoordinatesToOriginal(tRet);
        return tRet;
    }


    /// <summary>
    /// 좌표를 원본 이미지 크기로 변환
    /// </summary>
    public void ConvertCoordinatesToOriginal(RecognitionResult result)
    {
        if (result.Objects == null || result.Objects.Count == 0)
            return;

        // 스케일 비율 계산
        float scaleX = result.OriginalImageSize.Width / result.ScaledImageSize.Width;
        float scaleY = result.OriginalImageSize.Height / result.ScaledImageSize.Height;

        float rX = result.RenderedImageSize.Width / result.OriginalImageSize.Width;
        float rY = result.RenderedImageSize.Height / result.OriginalImageSize.Height;

        Console.WriteLine($"좌표 변환: Scale X={scaleX:F2}, Y={scaleY:F2}");

        foreach (var obj in result.Objects)
        {
            if (obj.BoundingBox != null)
            {
                // 스케일된 좌표를 원본 좌표로 변환
                obj.OriginalBoundingBox = new BoundingBox
                {
                    X = (int)(obj.BoundingBox.X * scaleX),
                    Y = (int)(obj.BoundingBox.Y * scaleY),
                    Width = (int)(obj.BoundingBox.Width * scaleX),
                    Height = (int)(obj.BoundingBox.Height * scaleY)
                };

                obj.RenderBoundingBox = new BoundingBox
                {
                    X = (int)(obj.OriginalBoundingBox.X * rX),
                    Y = (int)(obj.OriginalBoundingBox.Y * rY),
                    Width = (int)(obj.OriginalBoundingBox.Width * rX),
                    Height = (int)(obj.OriginalBoundingBox.Height * rY)
                };

                Console.WriteLine($"객체 '{obj.Name}': 스케일({obj.BoundingBox}) → 원본({obj.OriginalBoundingBox})");

            }
        }
    }

    // 리소스 정리
    public async ValueTask DisposeAsync()
    {
        if (isCameraActive)
        {
            await StopCamera();
        }

        dotnetReference?.Dispose();

        //if (jsModule != null)
        //{
        //    await jsModule.DisposeAsync();
        //}
    }

    // 비디오 정보 클래스
    public class VideoInfo
    {
        public int Width { get; set; }
        public int Height { get; set; }
        public int ReadyState { get; set; }
        public bool Paused { get; set; }
        public int renderedWidth { get; set; }
        public int renderedHeight { get; set; }
    }

}


